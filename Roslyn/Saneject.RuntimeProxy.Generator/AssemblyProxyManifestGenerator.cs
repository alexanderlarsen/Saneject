using System.Collections.Generic;
using System.Linq;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace Saneject.RuntimeProxy.Generator;

[Generator]
public class AssemblyProxyManifestGenerator : ISourceGenerator
{
    private static readonly SymbolDisplayFormat TypeofFormat = new
    (
        globalNamespaceStyle: SymbolDisplayGlobalNamespaceStyle.Omitted,
        typeQualificationStyle: SymbolDisplayTypeQualificationStyle.NameAndContainingTypesAndNamespaces,
        genericsOptions: SymbolDisplayGenericsOptions.None,
        miscellaneousOptions: SymbolDisplayMiscellaneousOptions.EscapeKeywordIdentifiers
    );

    public void Initialize(GeneratorInitializationContext context)
    {
        context.RegisterForSyntaxNotifications(() => new BindingMethodReceiver());
    }

    public void Execute(GeneratorExecutionContext context)
    {
        if (context.SyntaxReceiver is not BindingMethodReceiver receiver)
            return;

        HashSet<string> requiredProxyTargets = [];

        foreach ((MethodDeclarationSyntax method, GenericNameSyntax generic) in receiver.Candidates)
        {
            SemanticModel model = context.Compilation.GetSemanticModel(method.SyntaxTree);

            if (model.GetDeclaredSymbol(method) is not { } methodSymbol)
                continue;

            if (!InheritsFromScope(methodSymbol.ContainingType))
                continue;

            // Success! At this point:
            // 1. Method is DeclareBindings
            // 2. Inside a Scope subclass
            // 3. Contains BindComponent<,>().FromRuntimeProxy()

            if (model.GetTypeInfo(generic.TypeArgumentList.Arguments[1]).Type is not INamedTypeSymbol concreteNamedType)
                continue;

            requiredProxyTargets.Add(
                concreteNamedType.ToDisplayString(TypeofFormat)
            );
        }

        string source =
            $$"""
              using System;
              using System.ComponentModel;

              namespace Saneject.RuntimeProxy.Generator
              {
                  /// <summary>
                  /// Generated by Saneject Roslyn tools.
                  /// Editor-only, compile-time manifest.
                  /// </summary>
                  [EditorBrowsable(EditorBrowsableState.Never)]
                  public static class AssemblyProxyManifest
                  {
                      public static readonly Type[] RequiredProxyTargets =
                      {
                          {{
                              string.Join(",", requiredProxyTargets.Select(target => $"typeof({target})"))
                          }}
                      };
                  }
              }
              """;

        context.AddSource
        (
            hintName: "AssemblyProxyManifest.g.cs",
            source: source
        );
    }

    private static bool InheritsFromScope(INamedTypeSymbol type)
    {
        while (type != null)
        {
            // TODO: Remove Experimental namespace when stable
            if (type.ToDisplayString() == "Plugins.Saneject.Experimental.Runtime.Scopes.Scope")
                return true;

            type = type.BaseType;
        }

        return false;
    }

    // Finds candidates for BindComponent<,>().FromRuntimeProxy()
    private sealed class BindingMethodReceiver : ISyntaxReceiver
    {
        public List<(MethodDeclarationSyntax method, GenericNameSyntax generic)> Candidates { get; } = [];

        public void OnVisitSyntaxNode(SyntaxNode node)
        {
            // 1. Only care about methods
            if (node is not MethodDeclarationSyntax method)
                return;

            // 2. Must be DeclareBindings
            if (method.Identifier.Text != "DeclareBindings")
                return;

            // 3. Must be protected override
            if (!method.Modifiers.Any(SyntaxKind.OverrideKeyword))
                return;

            // 4. Only protected methods
            if (!method.Modifiers.Any(SyntaxKind.ProtectedKeyword))
                return;

            // 5. Method must have a body
            if (method.Body is null)
                return;

            // 6. Scan invocations inside the method body
            foreach (InvocationExpressionSyntax invocation in method.Body.DescendantNodes().OfType<InvocationExpressionSyntax>())
            {
                // We only care about `.FromRuntimeProxy()`
                if (invocation.Expression is not MemberAccessExpressionSyntax member)
                    continue;

                if (member.Name.Identifier.Text != "FromRuntimeProxy")
                    continue;

                // The expression before `.FromRuntimeProxy()`
                if (member.Expression is not InvocationExpressionSyntax bindInvocation)
                    continue;

                // Must be BindComponent<,>()
                if (bindInvocation.Expression is not GenericNameSyntax generic)
                    continue;

                if (generic.Identifier.Text != "BindComponent")
                    continue;

                // Must have exactly two generic args <TInterface, TConcrete>
                if (generic.TypeArgumentList.Arguments.Count != 2)
                    continue;

                // At this point, this is a valid syntax match
                Candidates.Add((method, generic));
            }
        }
    }
}